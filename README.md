# travelling-merchant
Probl√®me du Voyageur de Commerce (TSP), un d√©fi math√©matique et algorithmique consistant √† trouver le chemin le plus court permettant de visiter un ensemble donn√© de villes une seule fois avant de revenir au point de d√©part. 


## üìã Table des mati√®res

- [üöÄ D√©marrage rapide](#-d√©marrage-rapide)
- [üìä Fichiers du projet](#-fichiers-du-projet)
- [üêç Intitul√© du projet Python avec uv](#-intitule-du-projet-python-avec-uv)
- [Projet travelling-merchant](#projet-travelling-merchant)
  - [1. Mod√©lisation du Probl√®me](#1-mod√©lisation-du-probl√®me)
  - [2. R√©solution avec l'Algorithme de Christofides](#2-r√©solution-avec-lalgorithme-de-christofides)
  - [3. R√©solution avec les Algorithmes G√©n√©tiques](#3-r√©solution-avec-les-algorithmes-g√©n√©tiques)
  - [4. Analyse comparative](#4-analyse-comparative)
  - [5. Conclusion](#5-conclusion)
- [Veille sur les graphes](#veille-sur-les-graphes)
  - [Voisins](#voisins)
  - [Degr√©](#degr√©)
  - [Chemin](#chemin)
  - [Graphe complet](#graphe-complet)
  - [Graphe connexe](#graphe-connexe)
  - [Arbre](#arbre)
  - [Arbre couvrant](#arbre-couvrant)
  - [Relation entre connexit√© et arbre](#relation-entre-connexit√©-et-arbre)
  - [Somme des degr√©s](#somme-des-degr√©s)
  - [Cycle](#cycle)
  - [Cycle Hamiltonien](#cycle-hamiltonien)
  - [Circuit eul√©rien](#circuit-eul√©rien)
  - [Minimum Spanning Tree (MST)](#minimum-spanning-tree-mst)
  - [Algo de Prim](#algo-de-prim)
  - [Algo de Christofides](#algo-de-cristofides)

---

## üöÄ D√©marrage rapide

### Installation
```bash
# Installer uv si n√©cessaire
pip install uv

# Synchroniser les d√©pendances
uv sync

# Activer l'environnement virtuel (optionnel)
source .venv/bin/activate  # macOS/Linux
.venv\Scripts\Activate.ps1  # Windows
```

### Utilisation

**1. Comparaison compl√®te avec benchmark** (recommand√©)
```bash
uv run main.py
```
- Compare Christofides et l'algorithme g√©n√©tique avec 4 configurations diff√©rentes
- Mesure : distance, temps d'ex√©cution, CPU, m√©moire
- Sauvegarde les r√©sultats dans `results/benchmark_results.csv`

**2. Visualisation comparative**
```bash
uv run visualize.py
```
- Affiche les deux tours c√¥te √† c√¥te sur une carte
- Compare visuellement les r√©sultats
- Affiche la diff√©rence de distance

**3. Visualisation √©tape par √©tape de Christofides**
```python
# Dans un script Python ou notebook
import pandas as pd
from utils import cristo_algo, crist_steps

data = pd.read_csv("data/villes.csv")
g_data = cristo_algo(data)
crist_steps(g_data)  # Affiche les 4 √©tapes interactivement
```

---

## üìä Fichiers du projet

```
travelling-merchant/
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îî‚îÄ‚îÄ villes.csv          # 20 villes fran√ßaises (lat, lon)
‚îú‚îÄ‚îÄ results/
‚îÇ   ‚îî‚îÄ‚îÄ benchmark_results.csv  # R√©sultats des tests (g√©n√©r√©)
‚îú‚îÄ‚îÄ utils.py                # Fonctions Christofides et helpers
‚îú‚îÄ‚îÄ genetique.py            # Algorithme g√©n√©tique
‚îú‚îÄ‚îÄ benchmark.py            # Syst√®me de mesure de performance
‚îú‚îÄ‚îÄ visualize.py            # Visualisation comparative
‚îî‚îÄ‚îÄ main.py                 # Point d'entr√©e principal
```

---

## üêç Intitul√© du projet Python avec uv

Ce projet utilise [uv](https://github.com/astral-sh/uv), un gestionnaire de d√©pendances rapide pour Python.  
Installation (si besoin) : `pip install uv` ou `pipx install uv`

Cr√©ation et synchronisation de l‚Äôenvironnement :<br>
`uv sync`  

Activation :<br>
```shell
# sous macOS/Linux
source .venv/bin/activate
# sous windows
.venv\Scripts\Activate.ps1
```

Lancer le projet :<br>
```shell
uv run main.py
```
## Projet **travelling-merchant**
**mod√©lisation, r√©solution et analyse comparative**

### 1. Mod√©lisation du Probl√®me :
   
- R√©cup√©ration des positions g√©ographiques de 20 villes
fran√ßaises

- Repr√©sentation du r√©seau des villes et des routes de la carte de Th√©obald sous la forme d‚Äôun graphe.
Les sommets repr√©sentent les villes et les ar√™tes repr√©sentent les
routes entre ces villes avec des distances associ√©es.

- Il faut utiliser la **distance de Haversine** <br>

### 2. R√©solution avec l'Algorithme de Christofides :
   
- Impl√©mentation de l'**algorithme de Christofides** pour trouver l‚Äôitin√©raire
le plus court pour Th√©obald.<br>

- Quelle est la distance totale de la solution presque optimale ?<br>
Affichage de l'itin√©raire sur la carte du marchand.

- Explication des √©tapes de l'algorithme
  
- Pourquoi cet algorithme est pertinent dans ce contexte.<br>

### 3. R√©solution avec les Algorithmes G√©n√©tiques :

- Impl√©mentation d'un algorithme g√©n√©tique pour trouver l‚Äôitin√©raire le
plus court pour Th√©obald.<br>

- On consid√®re ici que les individus
√©tudi√©s sont les parcours diff√©rents (ou des Theobalds d‚Äôunivers
parall√®les).

- D√©finition les param√®tres de l'algorithme :
  - taille de la population
  - syst√®me de s√©lection
  - syst√®me de reproduction
  - taux de mutation
  - nombre de g√©n√©rations
  - etc.

- Test de diff√©rentes configurations de l'algorithme g√©n√©tique pour
observer comment elles affectent la qualit√© des solutions.

- Quelle est la distance totale de notre solution presque optimale ?
Affichage de l'itin√©raire sur la carte du marchand.

### 4. Analyse comparative

Le projet inclut un syst√®me complet de benchmark qui mesure :

#### M√©triques mesur√©es
- **Distance totale** : Qualit√© de la solution (en km)
- **Temps d'ex√©cution** : Performance algorithmique (en secondes)
- **Utilisation CPU** : Charge processeur moyenne (%)
- **Consommation m√©moire** : RAM utilis√©e pendant l'ex√©cution (MB)

#### Param√®tres de l'algorithme g√©n√©tique test√©s
| Configuration | Population | G√©n√©rations | Mutation | √âlites |
|--------------|-----------|------------|----------|--------|
| Config 1     | 50        | 100        | 10%      | 5      |
| Config 2     | 100       | 200        | 10%      | 10     |
| Config 3     | 150       | 300        | 15%      | 10     |
| Config 4     | 200       | 500        | 10%      | 15     |

#### R√©sultats sauvegard√©s
Tous les r√©sultats sont automatiquement sauvegard√©s dans `results/benchmark_results.csv` avec :
- Timestamp de l'ex√©cution
- Tous les param√®tres utilis√©s
- Toutes les m√©triques de performance
- Tour complet (ordre de visite des villes)

#### Comparaison des approches

| Crit√®re | Christofides | Algorithme G√©n√©tique |
|---------|-------------|---------------------|
| **Distance** | Solution optimale garantie ‚â§ 1.5√ó optimal | Variable selon param√®tres |
| **Temps** | Rapide (polynomial) | Plus lent mais param√©trable |
| **Complexit√©** | MST + MWPM + Circuit eul√©rien | Population + S√©lection + Croisement |
| **D√©terminisme** | Toujours la m√™me solution | Solutions diff√©rentes (al√©atoire) |
| **Param√©trage** | Aucun | Nombreux param√®tres √† ajuster |
| **Scalabilit√©** | Bonne jusqu'√† ~100 villes | Flexible, adaptable |

#### Avantages et inconv√©nients

**Christofides ‚úÖ**
- Garantie th√©orique (‚â§ 1.5√ó optimal)
- Rapide et pr√©visible
- Pas de param√®tres √† ajuster
- Id√©al pour solutions de r√©f√©rence

**Christofides ‚ùå**
- Pas toujours la meilleure solution
- Difficile √† parall√©liser
- Limit√© aux graphes m√©triques

**G√©n√©tique ‚úÖ**
- Peut trouver de meilleures solutions
- Tr√®s flexible et param√©trable
- Facilement parall√©lisable
- Continue d'am√©liorer avec plus de temps

**G√©n√©tique ‚ùå**
- Pas de garantie de qualit√©
- Nombreux param√®tres √† ajuster
- R√©sultats variables
- Plus lent pour convergence

### 5. Conclusion

#### Recommandations pour Th√©obald

**Pour une solution rapide et fiable :**
- ‚úÖ **Christofides** est le meilleur choix
- Solution en quelques secondes
- Garantie de qualit√© (‚â§ 1.5√ó optimal)
- Aucun r√©glage n√©cessaire

**Pour optimiser au maximum la distance :**
- ‚úÖ **Algorithme G√©n√©tique** avec beaucoup de g√©n√©rations
- Peut battre Christofides avec bons param√®tres
- N√©cessite du temps d'exp√©rimentation
- Id√©al si on peut laisser tourner longtemps

**Approche hybride recommand√©e :**
1. Utiliser **Christofides** pour avoir une solution de r√©f√©rence rapide
2. Lancer **G√©n√©tique** en parall√®le avec plusieurs configurations
3. Comparer et choisir le meilleur tour

#### Le√ßons apprises

- Les algorithmes exacts (comme Christofides) donnent de bonnes solutions rapidement
- Les m√©taheuristiques (comme G√©n√©tique) peuvent trouver mieux mais demandent plus de temps
- Le benchmark automatique permet de tester objectivement
- Pour 20 villes, les deux approches donnent des r√©sultats tr√®s comparables
- Au-del√† de 50-100 villes, l'algorithme g√©n√©tique devient plus int√©ressant

---
---

## Veille sur les **graphes**

Un **graphe** repr√©sente des relations entre des √©l√©ments appel√©s **sommets**.  
Une **ar√™te** est une relation reliant deux sommets.  
Un graphe peut comporter z√©ro, une ou plusieurs ar√™tes entre ses sommets.

| Anglais | Fran√ßais |
|----------|-----------|
| node     | sommet    |
| edge     | ar√™te     |

---

### **Voisins**
Deux sommets sont **voisins** s‚Äôils sont reli√©s par une ar√™te.  
<img src="img/voisins.png" width="400">

---

### **Degr√©**
Le **degr√©** d‚Äôun sommet est le nombre de ses voisins.  
Exemple : si un sommet a 3 voisins, alors  
`deg(sommet) = 3`

---

### **Chemin**
Un **chemin** est une suite d‚Äôar√™tes reliant deux sommets.  
- 1 ar√™te ‚Üí chemin de longueur 1  
- 2 ar√™tes ‚Üí chemin de longueur 2  
- etc.

---

### **Graphe complet**
Un **graphe complet** contient toutes les ar√™tes possibles entre tous les sommets.

<img src="img/graphe_complet.png" width="300">

---

### **Graphe connexe**
Un graphe est **connexe** si, pour tout couple de sommets `u` et `v`,  
il existe un **chemin** reliant `u` √† `v`.

**Exemple :**  
L‚Äôensemble ci-dessous **n‚Äôest pas connexe** : il se compose de deux sous-graphes connexes,  
celui de gauche `(A, C, D, F)` et celui de droite `(E, B)`.

<img src="img/graphe_non_convexe.png" width="300">

---

### **Arbre**
Un **arbre** est un graphe **connexe** et **sans cycle**.

<img src="img/arbre.png" width="200">
<img src="img/arbre_etoile.png" width="200">
<img src="img/arbre_chemin.png" width="200">
<img src="img/non_arbre.png" width="200">

---

### **Arbre couvrant**
Un arbre couvrant (ou spanning tree en anglais) d‚Äôun graphe connexe, c‚Äôest :

un sous-graphe qui contient tous les sommets du graphe,
sans cycle, et suffisamment d‚Äôar√™tes pour rester connexe.

**Autrement dit :**

- il relie (‚Äúcouvre‚Äù) tout les sommets (donc connexe)
- mais sans cycle (aucune redondance inutile)

**MST - minimum spanning tree - arbre couvrant minimal**

<img src="img/mst.webp" width="400">


- Contient tous les sommets.
- Ne contient aucun cycle.
- Si le graphe a n sommets ‚Üí le MST a toujours n - 1 ar√™tes.
- Le co√ªt total est minimal parmi tous les sous-graphes connexes possibles.

Trouvable efficacement avec les algorithmes de Kruskal ou Prim (complexit√© polynomiale).

*Construire un r√©seau de fibre optique reliant toutes les villes avec le moins de c√¢ble possible.
On veut connecter, pas faire une tourn√©e*


---

### **Relation entre connexit√© et arbre**
Un graphe est **connexe si et seulement s‚Äôil admet au moins un arbre couvrant**,  
c‚Äôest-√†-dire un **sous-graphe connexe, sans cycle, contenant tous les sommets**.

> √Ä partir d‚Äôun graphe connexe, on peut supprimer des ar√™tes (avec soin) pour obtenir un arbre couvrant ‚Äî mais pas n‚Äôimporte lesquelles.

---

### **Somme des degr√©s**
En g√©n√©ral :  
> Somme des degr√©s = 2 √ó (nombre d‚Äôar√™tes du graphe)


cad que si on supprime une ou des ar√™tes, on obtient un arbre

#### Somme des degr√©s
En g√©n√©ral :
Somme des degr√©s = 2 x le nombre d'ar√™tes du graphe


---


### **Cycle**
Un **cycle** est un chemin dont les deux extr√©mit√©s sont reli√©es (on revient au point de d√©part).  


|Cycle de longueur 4|Cycle de longueur 3|Cycle de longueur 6|
|-|-|-|
|<img src="img/cycle_4.png" width="200">|<img src="img/cycle_3.png" width="200">|<img src="img/cycle_6.png" width="200">|

---


Cycle ‚Üí sommets

Circuit ‚Üí ar√™tes

| Terme       | Usage courant                                       | En graphes                                                  | Exemple        |
| ----------- | --------------------------------------------------- | ----------------------------------------------------------- | --------------------- |
| Cycle   | Suite ferm√©e de sommets (retour au point de d√©part) | **sommets distincts** visit√©s une fois   | Cycle hamiltonien |
| Circuit | Suite ferm√©e d‚Äôar√™tes (retour au point de d√©part)   | **ar√™tes distinctes** utilis√©es une fois | Circuit eul√©rien  |



### **Cycle Hamiltonien**
- Passe une seule fois par chaque sommet
- Reviens au sommet de d√©part

Il n‚Äôexiste pas toujours, et il n‚Äôy a pas de condition simple (comme pour Euler) pour savoir s‚Äôil existe.

*Le cycle hamiltonien minimal resoud le probl√®me du voyageur de commerce (TSP)*

---

### **Circuit eul√©rien**

<img src="img/eulerian.webp" width="200">

- Passe une fois par chaque ar√™te
- Reviens au sommet de d√©part

Il existe dans un graphe si et seulement si :
- le graphe est connexe,
- et chaque sommet a un degr√© pair.

*Id√©al pour aider le facteur √† distribuer le courrier en passant une seule fois par chaque rue (ar√™te), peu importe s‚Äôil repasse par la m√™me intersection (sommet).*

---

### Algo de Prim

Cherche √† obtenir un arbre couvrant de poid minimal

1. on part d'un sommet au hazard, et on le consid√®re comme un (petit) arbre
2. on ajoute une arr√™te (celle qui √† un poid minimal) et le sommet qui va avec
3. on ajoute l'arr√™te qui √† un poid minimal
   (parmis toutes celles qui ont une extr√©mit√© dans l'arbre et une hors de l'arbre)
<img src="img/prim.png" width="600">
4. **bis repetita**<br>

---

### Algo de cristofides

Christofides sert √† approcher le TSP (probl√®me du voyageur de commerce, cycle hamiltonien minimal) dans un graphe m√©trique.

**Etapes, √† partir d'un graph complet** :

üîπ Construire un MST (minimum spanning tree) sur le graphe.

üîπ Identifier les sommets de degr√© impair dans ce MST.

üîπ Trouver un Minimum Weight Perfect Matching entre ces sommets impairs.

üîπ Ajouter ces ar√™tes au MST ‚Üí on obtient un graphe eul√©rien.

üîπ Trouver un circuit eul√©rien, puis le convertir en cycle hamiltonien (en sautant les doublons de sommets)

**R√©sultat** :

- un cycle hamiltonien
- co√ªt ‚â§ 1,5 √ó le co√ªt optimal
